{
    "name": "Christophe Calvès",
    "bio": "Christophe is a R&D Data-Engineer at MFG Labs. Passionate about solving problems he uses types and functional programming to build fast and reliable software. He likes to share with others experience and knowledge (and beer!). He especially focus on giving new comers the keys to feel comfortable with intimidating concepts.",
    "twitter": "chrilves",
    "company": "MFG Labs",
    "url": "https://chrilves.github.io",
    "avatar": "https://secure.gravatar.com/avatar/24ef18021486d7d91350b230825513b0?s=500",
    "talks": [
        {
            "title": "10 tips to write fast stack-safe functional code in Scala: the automatic-batching library experience report",
            "description": "Have you ever heard the belief of functional programming being slow? Have you ever been caught by a `StackOverflowError` in your recursive functions? Have you ever rewritten your functional code into imperative style to make it fast and stack-safe? What if i told you how to write fast and stack-safe functional code? Even for non tail-recursive functions! ;)\r\n\r\nIn this talk i'll present you 10 tips to write fast and stack-safe functional code. It is based on my experience implementing [Auto-Batch](https://github.com/chrilves/auto-batch), a pure functional-programming Scala library to automatically batch API calls.\r\n\r\nThrough these 10 tips, we'll discuss many subjects together: what `@tailrec` really means and how to bypass it, how to make most functions tail-recursive, how to be sure your code is really stack-safe, which free data-structure to choose for your need, how to use smart constructors to speed things up, \"hidden\" features of the IO monads, applicatives vs monads, why parametricity is your friend, are Generalized Algebraic Data Types really useful (spoiler alert, they are!), is there a concrete use-case of continuation-passing style, ...",
            "abstract": "You like writing elegant functional code but you need it to be fast? You enjoy recursion but fear the big bad stack-overflow?\nFear no more! In this talk i'll present you 10 tips i've used in Auto-Batch, a Scala FP library for automatically batching\napi calls, to make it fast and safe.",
            "audience_level": "Intermediate",
            "talk_format": "Talk (45 minutes)",
            "tags": [
                "effect-systems",
                "taming-recursion",
                "🇬🇧",
                "functional programming"
            ]
        },
        {
            "title": "GADTs by use-cases in Scala",
            "description": "\r\n🇫🇷\r\nTL;DR: Tu aimes le type-system de Scala mais le trouve parfois complexe? Ce workshop est fait pour toi! Viens découvrir les types algébriques généralisés (GADT) par la pratique de nombreux use-cases: prédicats sur les types, raffinement de types, effets, dérivation d'implicits, ...\r\n\r\nLes langages fonctionnels sont souvent appréciés pour la facilité et fiabilité qu’ils offrent à définir et manipuler des structures de données au plus près du métier: `case class`, `sealed trait`, *pattern-matching* (`match-case`), etc... Quelques langages fonctionnels, dont Scala, vont encore plus loin en permettant:\r\n\r\n- d’exprimer des prédicats sur les types comme “le type T est supporté par la base de donnée” ou “les types A et B types sont égaux”.\r\n- de restreindre des fonctions ou `case class` à des familles de types comme “cette fonction est uniquement définie sur les types T supportés par la base de données”.\r\n- d’exprimer des effets algébriques comme “la base de données supporte telle et telle opérations”.\r\n- de dériver des implicits par des fonctions normales qui peuvent inspecter la structure du type concerné.\r\n- et même de la programmation au type-level.\r\nCes structures sont appelées types algébriques généralisés ou GADT.\r\n\r\nIls ont malheureusement la réputation d’être difficile à appréhender et peu utiles. Notre expérience nous a pourtant montré que les GADT offrent des solutions simples et performantes aux challenges cités plus haut. Ce workshop, contrairement aux présentations usuelles, se concentre sur ces usages pratiques. Il vise à faire naître l’intuition de l’auditoire par l’expérimentation dans ces situations du quotidien. Et par là même, leur offrir une trousse à outils concrète pour faire face à ces problématiques.\r\n\r\nCe workshop a été conçu pour s’adapter à un large éventail de participant·e·s, du/de la débutant·e, connaissant déjà `case classes`, `sealed trait` et *pattern-matching* mais n’ayant jamais entendu parler de GADT, aux expert·e·s Scala jouant au type-level.\r\nOn vous attend nombreux.\r\n\r\n🇬🇧\r\nTL;DR: You like the Scala type-system but find it complex sometimes? This workshop is made for you! Come discover Generalized Algebraic Data Types (GADT) through practicing many use-cases: type predicates, type refinement, expressing effects, implicit derivation, type-level programming, …\r\n\r\nFunctional languages are appreciated due to the fact they are easy to use and their reliability to define and handle data structures close to the business: `case class`, `sealed trait`, *pattern-matching* (`match-case`), etc… Some of them, like Scala, go even further by:\r\n\r\n- Expressing predicates on types like “type T is supported by the database” or “types A et B are equals”\r\n- Restraining functions or `case class` to families of types like “this function is defined only on types T supported by the database”\r\n- Expressing algebraic effects like “the database supports only these operations”.\r\n- Deriving implicits with regular functions which can inspect the structure of the type.\r\n- Even type-level programming.\r\nThese structures are called Generalized Algebraic Data Types.\r\n\r\nThey are unfortunately reputed to be difficult to apprehend and not very useful. Our experience shows us you can come up with simple and effective solutions to the problems given above using GADT. This workshop, unlike usual presentations, will be focused on practical use cases. Its aim is to help the assistance develop their insight by practicing on these everyday situations and give them a practical toolkit to deal with these issues.\r\n\r\nThis workshop was designed to fit a large range of attendees, from the beginner, which already knows `case classes`, `sealed trait` et *pattern-matching* but has never heard about GADT, to the Scala type-level expert.\r\nWe are waiting for you.\r\n",
            "abstract": "In 🇫🇷 & 🇬🇧.\nYou like the Scala type-system but find it complex sometimes? This workshop is made for you! Come discover Generalized Algebraic Data Types (GADT) through practicing many use-cases: type predicates, type refinement, expressing effects, implicit derivation, type-level programming ...",
            "audience_level": "Intermediate",
            "talk_format": "Workshop (3 hours)",
            "tags": [
                "🇫🇷",
                "🇬🇧",
                "scala",
                "adt",
                "gadt",
                "workshop"
            ]
        }
    ]
}