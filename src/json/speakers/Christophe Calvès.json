{
    "name": "Christophe CalvÃ¨s",
    "bio": "Christophe is a R&D Data-Engineer at MFG Labs. Passionate about solving problems he uses types and functional programming to build fast and reliable software. He likes to share with others experience and knowledge (and beer!). He especially focus on giving new comers the keys to feel comfortable with intimidating concepts.",
    "twitter": "chrilves",
    "company": "MFG Labs",
    "url": "https://chrilves.github.io",
    "avatar": "https://secure.gravatar.com/avatar/24ef18021486d7d91350b230825513b0?s=500",
    "talks": [
        {
            "title": "10 tips to write fast stack-safe functional code in Scala: the automatic-batching library experience report",
            "description": "Have you ever heard the belief of functional programming being slow? Have you ever been caught by a `StackOverflowError` in your recursive functions? Have you ever rewritten your functional code into imperative style to make it fast and stack-safe? What if i told you how to write fast and stack-safe functional code? Even for non tail-recursive functions! ;)\r\n\r\nIn this talk i'll present you 10 tips to write fast and stack-safe functional code. It is based on my experience implementing [Auto-Batch](https://github.com/chrilves/auto-batch), a pure functional-programming Scala library to automatically batch API calls.\r\n\r\nThrough these 10 tips, we'll discuss many subjects together: what `@tailrec` really means and how to bypass it, how to make most functions tail-recursive, how to be sure your code is really stack-safe, which free data-structure to choose for your need, how to use smart constructors to speed things up, \"hidden\" features of the IO monads, applicatives vs monads, why parametricity is your friend, are Generalized Algebraic Data Types really useful (spoiler alert, they are!), is there a concrete use-case of continuation-passing style, ...",
            "abstract": "You like writing elegant functional code but you need it to be fast? You enjoy recursion but fear the big bad stack-overflow?\nFear no more! In this talk i'll present you 10 tips i've used in Auto-Batch, a Scala FP library for automatically batching\napi calls, to make it fast and safe.",
            "audience_level": "Intermediate",
            "talk_format": "Talk (45 minutes)",
            "tags": [
                "effect-systems",
                "taming-recursion",
                "ğŸ‡¬ğŸ‡§",
                "functional programming"
            ]
        },
        {
            "title": "GADTs by use-cases in Scala",
            "description": "\r\nğŸ‡«ğŸ‡·\r\nTL;DR: Tu aimes le type-system de Scala mais le trouve parfois complexe? Ce workshop est fait pour toi! Viens dÃ©couvrir les types algÃ©briques gÃ©nÃ©ralisÃ©s (GADT) par la pratique de nombreux use-cases: prÃ©dicats sur les types, raffinement de types, effets, dÃ©rivation d'implicits, ...\r\n\r\nLes langages fonctionnels sont souvent apprÃ©ciÃ©s pour la facilitÃ© et fiabilitÃ© quâ€™ils offrent Ã  dÃ©finir et manipuler des structures de donnÃ©es au plus prÃ¨s du mÃ©tier: `case class`, `sealed trait`, *pattern-matching* (`match-case`), etc... Quelques langages fonctionnels, dont Scala, vont encore plus loin en permettant:\r\n\r\n- dâ€™exprimer des prÃ©dicats sur les types comme â€œle type T est supportÃ© par la base de donnÃ©eâ€ ou â€œles types A et B types sont Ã©gauxâ€.\r\n- de restreindre des fonctions ou `case class` Ã  des familles de types comme â€œcette fonction est uniquement dÃ©finie sur les types T supportÃ©s par la base de donnÃ©esâ€.\r\n- dâ€™exprimer des effets algÃ©briques comme â€œla base de donnÃ©es supporte telle et telle opÃ©rationsâ€.\r\n- de dÃ©river des implicits par des fonctions normales qui peuvent inspecter la structure du type concernÃ©.\r\n- et mÃªme de la programmation au type-level.\r\nCes structures sont appelÃ©es types algÃ©briques gÃ©nÃ©ralisÃ©s ou GADT.\r\n\r\nIls ont malheureusement la rÃ©putation dâ€™Ãªtre difficile Ã  apprÃ©hender et peu utiles. Notre expÃ©rience nous a pourtant montrÃ© que les GADT offrent des solutions simples et performantes aux challenges citÃ©s plus haut. Ce workshop, contrairement aux prÃ©sentations usuelles, se concentre sur ces usages pratiques. Il vise Ã  faire naÃ®tre lâ€™intuition de lâ€™auditoire par lâ€™expÃ©rimentation dans ces situations du quotidien. Et par lÃ  mÃªme, leur offrir une trousse Ã  outils concrÃ¨te pour faire face Ã  ces problÃ©matiques.\r\n\r\nCe workshop a Ã©tÃ© conÃ§u pour sâ€™adapter Ã  un large Ã©ventail de participantÂ·eÂ·s, du/de la dÃ©butantÂ·e, connaissant dÃ©jÃ  `case classes`, `sealed trait` et *pattern-matching* mais nâ€™ayant jamais entendu parler de GADT, aux expertÂ·eÂ·s Scala jouant au type-level.\r\nOn vous attend nombreux.\r\n\r\nğŸ‡¬ğŸ‡§\r\nTL;DR: You like the Scala type-system but find it complex sometimes? This workshop is made for you! Come discover Generalized Algebraic Data Types (GADT) through practicing many use-cases: type predicates, type refinement, expressing effects, implicit derivation, type-level programming, â€¦\r\n\r\nFunctional languages are appreciated due to the fact they are easy to use and their reliability to define and handle data structures close to the business: `case class`, `sealed trait`, *pattern-matching* (`match-case`), etcâ€¦ Some of them, like Scala, go even further by:\r\n\r\n- Expressing predicates on types like â€œtype T is supported by the databaseâ€ or â€œtypes A et B are equalsâ€\r\n- Restraining functions or `case class` to families of types like â€œthis function is defined only on types T supported by the databaseâ€\r\n- Expressing algebraic effects like â€œthe database supports only these operationsâ€.\r\n- Deriving implicits with regular functions which can inspect the structure of the type.\r\n- Even type-level programming.\r\nThese structures are called Generalized Algebraic Data Types.\r\n\r\nThey are unfortunately reputed to be difficult to apprehend and not very useful. Our experience shows us you can come up with simple and effective solutions to the problems given above using GADT. This workshop, unlike usual presentations, will be focused on practical use cases. Its aim is to help the assistance develop their insight by practicing on these everyday situations and give them a practical toolkit to deal with these issues.\r\n\r\nThis workshop was designed to fit a large range of attendees, from the beginner, which already knows `case classes`, `sealed trait` et *pattern-matching* but has never heard about GADT, to the Scala type-level expert.\r\nWe are waiting for you.\r\n",
            "abstract": "In ğŸ‡«ğŸ‡· & ğŸ‡¬ğŸ‡§.\nYou like the Scala type-system but find it complex sometimes? This workshop is made for you! Come discover Generalized Algebraic Data Types (GADT) through practicing many use-cases: type predicates, type refinement, expressing effects, implicit derivation, type-level programming ...",
            "audience_level": "Intermediate",
            "talk_format": "Workshop (3 hours)",
            "tags": [
                "ğŸ‡«ğŸ‡·",
                "ğŸ‡¬ğŸ‡§",
                "scala",
                "adt",
                "gadt",
                "workshop"
            ]
        }
    ]
}